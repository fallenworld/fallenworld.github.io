---
layout: post
title: C语言中的地址对齐
categories: C/C++
tags: C/C++
---

* content
{:toc}

## 对齐的原因 ##

在常见的体系结构中，CPU读写内存通常是以字为单位的，而非单个字节。例如在32位X86上读写内存是以32位（即4字节）为单位的。

如果一个数据在内存空间中横跨了多个字的话，那么读写这个数据就需要读写多个字，这样就浪费了时间，降低了程序效率。

因此编译器为了提升程序效率，会把程序中的数据放到尽量少的字内，做到这一点的方法就是进行对齐。

##  对齐的原则 ##

每一种类型都有一个“对齐值”，不同的类型会有不同的“对齐值”

C语言中的对齐要遵循以下两个原则：

1. 变量的地址必须是其“对齐值”的整数倍
2. 变量的大小必须是其“对齐值”的整数倍

其中变量的地址包括了作为结构体成员的情况，如果是结构体成员的话，那么相对于结构体起始地址的偏移量必须是“对齐值”的整数倍

上面的原则用公式可以表示为：  
address % align_value == 0  
sizeof(type) % align_value == 0  

## 对齐值的计算方法 ##

首先编译器会有一个“编译器对齐值”，这个值和编译器有关，大部分编译器中默认64位系统上是8字节，32位系统上是4字节。一个类型的“对齐值”由这个类型本身和编译器对齐值共同决定。

编译器的对齐值可以通过一些编译器的拓展指令来设置，VC中可以用#pragma pack(xxx)，gcc中可以用__attribute__((aligned(xxx)))

不同类型的“对齐值”的计算方法是不一样的，下面分几种不同的类型来来讨论“对齐值”的计算方法

### 一般类型 ###

一般类型包括char、short、int、long、float、double、指针等

一般类型的“对齐值” = “该类型的大小” 和 “编译器对齐值” 中的较小值

例如：若编译器对齐值为4，则char对齐值为1，double对齐值为4。若编译器对齐值为8，则double对齐值为8

### 数组 ###

数组的“对齐值” = 数组元素的“对齐值”

使用typedef时也是如此

例如：
```c
typedef char NewType[4];
char a[3];
NewType b;
```
a的对齐值为1而不是3，b的对齐值也是1而不是4

### 结构体和共用体 ###

结构体 / 共用体的“对齐值” = “该结构体 / 共用体所有成员的对齐值中的最大值” 和 “编译器对齐值” 二者中的较小值

例如：

```c
struct A
{
    char a;
    short b;
    int c;
};
```

若编译器对齐值为4，int的大小为4，则结构体A的对齐值为4，因为所有成员中对齐值最大的是int为4