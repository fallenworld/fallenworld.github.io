---
layout: post
title: C++中的构造函数(二)：构造函数代码扩张
categories: C++底层解析
tags: C/C++
---

* content
{:toc}

## 构造函数代码扩张 ##

编译器对构造函数的代码扩张是指：

有些情况下，在编译器最终生成的代码中，除了用户自己写在构造函体内部的那些代码以外，编译器还会向用户定义的每一个构造函数里添加一些额外的代码，来实现一些特定的功能。

## 构造函数代码扩张的四种情况 ##

在C++11中，总共有四种会发生构造函数代码扩张的情况：

#### 包含类成员或继承自父类 ####

若一个类是继承自父类的或者它的某些成员变量的类型也是是类，此时为了初始化父类和类成员，如果这些类的默认构造函数不是trival的（默认构造函数的trival和non-trival可参考[C++中的构造函数(一)：默认构造函数](http://blog.fallenworld.org/2017/02/09/the-cpp-constructor-1/)），编译器会在每一个构造函数的开头添加调用这些类的默认构造函数的代码，例如：

```c++
class A : public B
{
public:
    C c;
    D d;
    int v;

    A();
    A(int value);
};
```

（注：上面代码中的B、C、D都是类）

此时编译器就会在为A定义的每个构造函数中调用B、C、D的默认构造函数

但是如果父类或者某个对象成员的默认构造函数是一个编译器合成的什么也不做的空的函数的话（即trival的），那么这个类的默认构造函数就不会被调用

#### 类内非静态成员初始化 ####

若一个类的类声明中包含**非静态成员**的类内初始化，则为了实现这个类内初始化，编译器会在构造函数开头添加初始化这个成员的代码，例如：

```c++
class A
{
    int a = 1;
    A();
};
```

此时编译器会在每个构造函数开头增加初始化a为1的代码

由此可知类内非静态成员初始化其实就是通过向构造函数中添加初始化代码来实现的

#### 构造函数包含初始化列表 ####

若构造函数有初始化列表，那么初始化列表中的初始化最终会被会被编译器转换为在构造函数开头用一些语句进行初始化，例如：

```c++
class A
{
    int a;
    int b;
    A();
};

A::A() : b(2), a(1)
{}
```
这时构造函数A::A()会被扩张成类似这个样子：

```c++
A::A()
{
    a = 1;
    b = 2;
}
```
由此可知初始化列表也是通过在构造函数开头添加初始化代码实现的

#### 包含虚函数或继承自虚基类 ####

若一个类中包含虚函数，或者这个类的继承链中包含虚基类，则此时构造函数中需要设置虚函数表指针和虚基类指针，因此编译器会在每个构造函数的开头添加设置虚函数表指针和设置虚基类指针的代码，例如：

```c++
class A : public virtual B
{
    A();
    virtual void fun();
};
```

## 参考资料 ##

《深度探索C++对象模型》 2.1节 

C++ Standard（ISO/IEC 14882-2011） 12.1节
